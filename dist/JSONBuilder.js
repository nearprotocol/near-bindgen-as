"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ast_1 = require("./ast");
const ASTBuilder_1 = require("./ASTBuilder");
const base_1 = require("./base");
function returnsVoid(node) {
    return toString(node.signature.returnType) === "void";
}
function numOfParameters(node) {
    return node.signature.parameters.length;
}
function hasNearDecorator(stmt) {
    return stmt.text.includes("@nearfile") || isEntry(stmt);
}
function toString(node) {
    return ASTBuilder_1.ASTBuilder.build(node);
}
function isEntry(source) {
    let _source = ((source.kind == ast_1.NodeKind.SOURCE ? source : source.range.source));
    return _source.sourceKind == ast_1.SourceKind.USER_ENTRY;
}
exports.isEntry = isEntry;
function isClass(type) {
    return type.kind == ast_1.NodeKind.CLASSDECLARATION;
}
function isField(mem) {
    return mem.kind == ast_1.NodeKind.FIELDDECLARATION;
}
// TODO: Extract this into separate module, preferrable pluggable
class JSONBindingsBuilder extends base_1.BaseVisitor {
    constructor() {
        super(...arguments);
        this.sb = [];
        this.exportedClasses = new Map();
        this.wrappedFuncs = new Set();
    }
    static build(parser, source) {
        return new JSONBindingsBuilder().build(source);
    }
    static nearFiles(parser) {
        return parser.program.sources.filter(hasNearDecorator);
    }
    visitClassDeclaration(node) {
        if (!this.exportedClasses.has(toString(node.name))) {
            this.exportedClasses.set(toString(node.name), node);
        }
        super.visitClassDeclaration(node);
    }
    visitFunctionDeclaration(node) {
        if (!isEntry(node) ||
            this.wrappedFuncs.has(toString(node.name)) ||
            !node.is(ast_1.CommonFlags.EXPORT) ||
            (numOfParameters(node) == 0 && returnsVoid(node))) {
            super.visitFunctionDeclaration(node);
            return;
        }
        this.generateWrapperFunction(node);
        // Change function to not be an export
        node.flags = node.flags ^ ast_1.CommonFlags.EXPORT;
        this.wrappedFuncs.add(toString(node.name));
        super.visit(node);
    }
    /*
    Create a wrapper function that will be export in the function's place.
    */
    generateWrapperFunction(func) {
        let signature = func.signature;
        let params = signature.parameters;
        let returnType = signature.returnType;
        let returnTypeName = toString(returnType)
            .split("|")
            .map(name => name.trim())
            .filter(name => name !== "null")
            .join("|");
        let hasNull = toString(returnType).includes("null");
        let name = func.name.text;
        this.sb.push(`function __wrapper_${name}(): void {`);
        if (params.length > 0) {
            this.sb.push(`  const obj = getInput();`);
        }
        if (toString(returnType) !== "void") {
            this.sb.push(`  let result: ${toString(returnType)} = ${name}(`);
        }
        else {
            this.sb.push(`  ${name}(`);
        }
        if (params.length > 0) {
            this.sb[this.sb.length - 1] += params
                .map(param => createDecodeStatement(param))
                .join(", ");
        }
        this.sb[this.sb.length - 1] += ");";
        if (toString(returnType) !== "void") {
            this.sb.push(`  const val = encode<${returnTypeName}>(${hasNull ? `changetype<${returnTypeName}>(result)` : "result"});
  value_return(val.byteLength, val.dataStart);`);
        }
        this.sb.push(`}
export { __wrapper_${name} as ${name} }`);
    }
    typeName(type) {
        if (!isClass(type)) {
            return ASTBuilder_1.ASTBuilder.build(type);
        }
        type = type;
        let className = toString(type.name);
        if (type.isGeneric) {
            className += "<" + type.typeParameters.map(toString).join(", ") + ">";
        }
        return className;
    }
    build(source) {
        this.sb = [];
        this.visit(source);
        let sourceText = source.statements.map(stmt => {
            let str = ASTBuilder_1.ASTBuilder.build(stmt);
            if (isClass(stmt)) {
                let _class = stmt;
                str = str.slice(0, str.lastIndexOf("}"));
                let fields = _class.members
                    .filter(isField)
                    .map((field) => field);
                if (fields.some(field => field.type == null)) {
                    throw new Error("All Fields must have explict type declaration.");
                }
                let className = this.typeName(_class);
                str += `
  decode<V = Uint8Array>(buf: V): ${className} {
    let json: JSON.Obj;
    if (buf instanceof Uint8Array) {
      json = JSON.parse(buf);
    } else {
      assert(buf instanceof JSON.Obj, "argument must be Uint8Array or Json Object");
      json = <JSON.Obj> buf;
    }
    return this._decode(json);
  }

  static decode(buf: Uint8Array): ${className} {
    return decode<${className}>(buf);
  }

  private _decode(obj: JSON.Obj): ${className} {
    ${createDecodeStatements(_class).join("\n    ")}
    return this;
  }

  _encode(name: string | null = "", _encoder: JSONEncoder | null = null): JSONEncoder {
    let encoder = (_encoder == null ? new JSONEncoder() : _encoder)!;
    encoder.pushObject(name);
    ${createEncodeStatements(_class).join("\n    ")}
    encoder.popObject();
    return encoder;
  }
  encode(): Uint8Array {
    return this._encode().serialize();
  }

  serialize(): Uint8Array {
    return this.encode();
  }

  toJSON(): string {
    return this._encode().toString();
  }
}`;
            }
            return str;
        });
        return sourceText.concat(this.sb).join("\n");
    }
}
exports.JSONBindingsBuilder = JSONBindingsBuilder;
function createDecodeStatements(_class) {
    return _class.members
        .filter(isField)
        .map((field) => {
        const name = toString(field.name);
        return (createDecodeStatement(field, `this.${name} = obj.has("${name}") ? `) +
            `: ${field.initializer != null ? ASTBuilder_1.ASTBuilder.build(field.initializer) : `this.${name}`};`);
    });
}
function createDecodeStatement(field, setterPrefix = "") {
    let T = toString(field.type);
    let name = toString(field.name);
    return `${setterPrefix}decode<${T}, JSON.Obj>(obj, "${name}")`;
}
function createEncodeStatements(_class) {
    return _class.members
        .filter(isField)
        .map((field) => {
        let T = toString(field.type);
        let name = toString(field.name);
        return `encode<${T}, JSONEncoder>(this.${name}, "${name}", encoder);`;
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSlNPTkJ1aWxkZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvSlNPTkJ1aWxkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSwrQkFhZTtBQUNmLDZDQUEwQztBQUMxQyxpQ0FBcUM7QUFFckMsU0FBUyxXQUFXLENBQUMsSUFBeUI7SUFDNUMsT0FBTyxRQUFRLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsS0FBSyxNQUFNLENBQUM7QUFDeEQsQ0FBQztBQUVELFNBQVMsZUFBZSxDQUFDLElBQXlCO0lBQ2hELE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDO0FBQzFDLENBQUM7QUFFRCxTQUFTLGdCQUFnQixDQUFDLElBQVk7SUFDcEMsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDMUQsQ0FBQztBQUVELFNBQVMsUUFBUSxDQUFDLElBQVU7SUFDMUIsT0FBTyx1QkFBVSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNoQyxDQUFDO0FBRUQsU0FBZ0IsT0FBTyxDQUFDLE1BQXFCO0lBQzNDLElBQUksT0FBTyxHQUFXLENBQ3BCLENBQUMsTUFBTSxDQUFDLElBQUksSUFBSSxjQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQ2hFLENBQUM7SUFDRixPQUFPLE9BQU8sQ0FBQyxVQUFVLElBQUksZ0JBQVUsQ0FBQyxVQUFVLENBQUM7QUFDckQsQ0FBQztBQUxELDBCQUtDO0FBRUQsU0FBUyxPQUFPLENBQUMsSUFBVTtJQUN6QixPQUFPLElBQUksQ0FBQyxJQUFJLElBQUksY0FBUSxDQUFDLGdCQUFnQixDQUFDO0FBQ2hELENBQUM7QUFFRCxTQUFTLE9BQU8sQ0FBQyxHQUF5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QyxDQUFDLENBQUM7QUFDUCxDQUFDO0FBRUQsU0FBUyxxQkFBcUIsQ0FDNUIsS0FBdUMsRUFDdkMsZUFBdUIsRUFBRTtJQUV6QixJQUFJLENBQUMsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLElBQUssQ0FBQyxDQUFDO0lBQzlCLElBQUksSUFBSSxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDaEMsT0FBTyxHQUFHLFlBQVksVUFBVSxDQUFDLHFCQUFxQixJQUFJLElBQUksQ0FBQztBQUNqRSxDQUFDO0FBRUQsU0FBUyxzQkFBc0IsQ0FBQyxNQUF3QjtJQUN0RCxPQUFPLE1BQU0sQ0FBQyxPQUFPO1NBQ2xCLE1BQU0sQ0FBQyxPQUFPLENBQUM7U0FDZixHQUFHLENBQUMsQ0FBQyxLQUF1QixFQUFVLEVBQUU7UUFDdkMsSUFBSSxDQUFDLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxJQUFLLENBQUMsQ0FBQztRQUM5QixJQUFJLElBQUksR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2hDLE9BQU8sVUFBVSxDQUFDLHVCQUF1QixJQUFJLE1BQU0sSUFBSSxjQUFjLENBQUM7SUFDeEUsQ0FBQyxDQUFDLENBQUM7QUFDUCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgTm9kZSxcbiAgRnVuY3Rpb25EZWNsYXJhdGlvbixcbiAgTm9kZUtpbmQsXG4gIFNvdXJjZSxcbiAgU291cmNlS2luZCxcbiAgVHlwZU5vZGUsXG4gIENsYXNzRGVjbGFyYXRpb24sXG4gIERlY2xhcmF0aW9uU3RhdGVtZW50LFxuICBQYXJzZXIsXG4gIENvbW1vbkZsYWdzLFxuICBGaWVsZERlY2xhcmF0aW9uLFxuICBQYXJhbWV0ZXJOb2RlLFxufSBmcm9tIFwiLi9hc3RcIjtcbmltcG9ydCB7IEFTVEJ1aWxkZXIgfSBmcm9tIFwiLi9BU1RCdWlsZGVyXCI7XG5pbXBvcnQgeyBCYXNlVmlzaXRvciB9IGZyb20gXCIuL2Jhc2VcIjtcblxuZnVuY3Rpb24gcmV0dXJuc1ZvaWQobm9kZTogRnVuY3Rpb25EZWNsYXJhdGlvbik6IGJvb2xlYW4ge1xuICByZXR1cm4gdG9TdHJpbmcobm9kZS5zaWduYXR1cmUucmV0dXJuVHlwZSkgPT09IFwidm9pZFwiO1xufVxuXG5mdW5jdGlvbiBudW1PZlBhcmFtZXRlcnMobm9kZTogRnVuY3Rpb25EZWNsYXJhdGlvbik6IG51bWJlciB7XG4gIHJldHVybiBub2RlLnNpZ25hdHVyZS5wYXJhbWV0ZXJzLmxlbmd0aDtcbn1cblxuZnVuY3Rpb24gaGFzTmVhckRlY29yYXRvcihzdG10OiBTb3VyY2UpOiBib29sZWFuIHtcbiAgcmV0dXJuIHN0bXQudGV4dC5pbmNsdWRlcyhcIkBuZWFyZmlsZVwiKSB8fCBpc0VudHJ5KHN0bXQpO1xufVxuXG5mdW5jdGlvbiB0b1N0cmluZyhub2RlOiBOb2RlKTogc3RyaW5nIHtcbiAgcmV0dXJuIEFTVEJ1aWxkZXIuYnVpbGQobm9kZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0VudHJ5KHNvdXJjZTogU291cmNlIHwgTm9kZSk6IGJvb2xlYW4ge1xuICBsZXQgX3NvdXJjZSA9IDxTb3VyY2U+KFxuICAgIChzb3VyY2Uua2luZCA9PSBOb2RlS2luZC5TT1VSQ0UgPyBzb3VyY2UgOiBzb3VyY2UucmFuZ2Uuc291cmNlKVxuICApO1xuICByZXR1cm4gX3NvdXJjZS5zb3VyY2VLaW5kID09IFNvdXJjZUtpbmQuVVNFUl9FTlRSWTtcbn1cblxuZnVuY3Rpb24gaXNDbGFzcyh0eXBlOiBOb2RlKTogYm9vbGVhbiB7XG4gIHJldHVybiB0eXBlLmtpbmQgPT0gTm9kZUtpbmQuQ0xBU1NERUNMQVJBVElPTjtcbn1cblxuZnVuY3Rpb24gaXNGaWVsZChtZW06IERlY2xhcmF0aW9uU3RhdGVtZW50KSB7XG4gIHJldHVybiBtZW0ua2luZCA9PSBOb2RlS2luZC5GSUVMRERFQ0xBUkFUSU9OO1xufVxuXG4vLyBUT0RPOiBFeHRyYWN0IHRoaXMgaW50byBzZXBhcmF0ZSBtb2R1bGUsIHByZWZlcnJhYmxlIHBsdWdnYWJsZVxuZXhwb3J0IGNsYXNzIEpTT05CaW5kaW5nc0J1aWxkZXIgZXh0ZW5kcyBCYXNlVmlzaXRvciB7XG4gIHByaXZhdGUgc2I6IHN0cmluZ1tdID0gW107XG4gIHByaXZhdGUgZXhwb3J0ZWRDbGFzc2VzOiBNYXA8c3RyaW5nLCBDbGFzc0RlY2xhcmF0aW9uPiA9IG5ldyBNYXAoKTtcbiAgd3JhcHBlZEZ1bmNzOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoKTtcblxuICBzdGF0aWMgYnVpbGQocGFyc2VyOiBQYXJzZXIsIHNvdXJjZTogU291cmNlKTogc3RyaW5nIHtcbiAgICByZXR1cm4gbmV3IEpTT05CaW5kaW5nc0J1aWxkZXIoKS5idWlsZChzb3VyY2UpO1xuICB9XG5cbiAgc3RhdGljIG5lYXJGaWxlcyhwYXJzZXI6IFBhcnNlcik6IFNvdXJjZVtdIHtcbiAgICByZXR1cm4gcGFyc2VyLnByb2dyYW0uc291cmNlcy5maWx0ZXIoaGFzTmVhckRlY29yYXRvcik7XG4gIH1cblxuICB2aXNpdENsYXNzRGVjbGFyYXRpb24obm9kZTogQ2xhc3NEZWNsYXJhdGlvbik6IHZvaWQge1xuICAgIGlmICghdGhpcy5leHBvcnRlZENsYXNzZXMuaGFzKHRvU3RyaW5nKG5vZGUubmFtZSkpKSB7XG4gICAgICB0aGlzLmV4cG9ydGVkQ2xhc3Nlcy5zZXQodG9TdHJpbmcobm9kZS5uYW1lKSwgbm9kZSk7XG4gICAgfVxuICAgIHN1cGVyLnZpc2l0Q2xhc3NEZWNsYXJhdGlvbihub2RlKTtcbiAgfVxuXG4gIHZpc2l0RnVuY3Rpb25EZWNsYXJhdGlvbihub2RlOiBGdW5jdGlvbkRlY2xhcmF0aW9uKTogdm9pZCB7XG4gICAgaWYgKFxuICAgICAgIWlzRW50cnkobm9kZSkgfHxcbiAgICAgIHRoaXMud3JhcHBlZEZ1bmNzLmhhcyh0b1N0cmluZyhub2RlLm5hbWUpKSB8fFxuICAgICAgIW5vZGUuaXMoQ29tbW9uRmxhZ3MuRVhQT1JUKSB8fFxuICAgICAgKG51bU9mUGFyYW1ldGVycyhub2RlKSA9PSAwICYmIHJldHVybnNWb2lkKG5vZGUpKVxuICAgICkge1xuICAgICAgc3VwZXIudmlzaXRGdW5jdGlvbkRlY2xhcmF0aW9uKG5vZGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmdlbmVyYXRlV3JhcHBlckZ1bmN0aW9uKG5vZGUpO1xuICAgIC8vIENoYW5nZSBmdW5jdGlvbiB0byBub3QgYmUgYW4gZXhwb3J0XG4gICAgbm9kZS5mbGFncyA9IG5vZGUuZmxhZ3MgXiBDb21tb25GbGFncy5FWFBPUlQ7XG4gICAgdGhpcy53cmFwcGVkRnVuY3MuYWRkKHRvU3RyaW5nKG5vZGUubmFtZSkpO1xuICAgIHN1cGVyLnZpc2l0KG5vZGUpO1xuICB9XG5cbiAgLypcbiAgQ3JlYXRlIGEgd3JhcHBlciBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhwb3J0IGluIHRoZSBmdW5jdGlvbidzIHBsYWNlLlxuICAqL1xuICBwcml2YXRlIGdlbmVyYXRlV3JhcHBlckZ1bmN0aW9uKGZ1bmM6IEZ1bmN0aW9uRGVjbGFyYXRpb24pIHtcbiAgICBsZXQgc2lnbmF0dXJlID0gZnVuYy5zaWduYXR1cmU7XG4gICAgbGV0IHBhcmFtcyA9IHNpZ25hdHVyZS5wYXJhbWV0ZXJzO1xuICAgIGxldCByZXR1cm5UeXBlID0gc2lnbmF0dXJlLnJldHVyblR5cGU7XG4gICAgbGV0IHJldHVyblR5cGVOYW1lID0gdG9TdHJpbmcocmV0dXJuVHlwZSlcbiAgICAgIC5zcGxpdChcInxcIilcbiAgICAgIC5tYXAobmFtZSA9PiBuYW1lLnRyaW0oKSlcbiAgICAgIC5maWx0ZXIobmFtZSA9PiBuYW1lICE9PSBcIm51bGxcIilcbiAgICAgIC5qb2luKFwifFwiKTtcbiAgICBsZXQgaGFzTnVsbCA9IHRvU3RyaW5nKHJldHVyblR5cGUpLmluY2x1ZGVzKFwibnVsbFwiKTtcbiAgICBsZXQgbmFtZSA9IGZ1bmMubmFtZS50ZXh0O1xuXG4gICAgdGhpcy5zYi5wdXNoKGBmdW5jdGlvbiBfX3dyYXBwZXJfJHtuYW1lfSgpOiB2b2lkIHtgKTtcbiAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuc2IucHVzaChgICBjb25zdCBvYmogPSBnZXRJbnB1dCgpO2ApO1xuICAgIH1cbiAgICBpZiAodG9TdHJpbmcocmV0dXJuVHlwZSkgIT09IFwidm9pZFwiKSB7XG4gICAgICB0aGlzLnNiLnB1c2goYCAgbGV0IHJlc3VsdDogJHt0b1N0cmluZyhyZXR1cm5UeXBlKX0gPSAke25hbWV9KGApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNiLnB1c2goYCAgJHtuYW1lfShgKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnNiW3RoaXMuc2IubGVuZ3RoIC0gMV0gKz0gcGFyYW1zXG4gICAgICAgIC5tYXAocGFyYW0gPT4gY3JlYXRlRGVjb2RlU3RhdGVtZW50KHBhcmFtKSlcbiAgICAgICAgLmpvaW4oXCIsIFwiKTtcbiAgICB9XG4gICAgdGhpcy5zYlt0aGlzLnNiLmxlbmd0aCAtIDFdICs9IFwiKTtcIjtcbiAgICBpZiAodG9TdHJpbmcocmV0dXJuVHlwZSkgIT09IFwidm9pZFwiKSB7XG4gICAgICB0aGlzLnNiLnB1c2goYCAgY29uc3QgdmFsID0gZW5jb2RlPCR7cmV0dXJuVHlwZU5hbWV9Pigke2hhc051bGwgPyBgY2hhbmdldHlwZTwke3JldHVyblR5cGVOYW1lfT4ocmVzdWx0KWAgOiBcInJlc3VsdFwifSk7XG4gIHZhbHVlX3JldHVybih2YWwuYnl0ZUxlbmd0aCwgdmFsLmRhdGFTdGFydCk7YCk7XG4gICAgfVxuICAgIHRoaXMuc2IucHVzaChgfVxuZXhwb3J0IHsgX193cmFwcGVyXyR7bmFtZX0gYXMgJHtuYW1lfSB9YCk7XG4gIH1cblxuICBwcml2YXRlIHR5cGVOYW1lKHR5cGU6IFR5cGVOb2RlIHwgQ2xhc3NEZWNsYXJhdGlvbik6IHN0cmluZyB7XG4gICAgaWYgKCFpc0NsYXNzKHR5cGUpKSB7XG4gICAgICByZXR1cm4gQVNUQnVpbGRlci5idWlsZCh0eXBlKTtcbiAgICB9XG4gICAgdHlwZSA9IDxDbGFzc0RlY2xhcmF0aW9uPnR5cGU7XG4gICAgbGV0IGNsYXNzTmFtZSA9IHRvU3RyaW5nKHR5cGUubmFtZSk7XG4gICAgaWYgKHR5cGUuaXNHZW5lcmljKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCI8XCIgKyB0eXBlLnR5cGVQYXJhbWV0ZXJzIS5tYXAodG9TdHJpbmcpLmpvaW4oXCIsIFwiKSArIFwiPlwiO1xuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9XG5cbiAgYnVpbGQoc291cmNlOiBTb3VyY2UpOiBzdHJpbmcge1xuICAgIHRoaXMuc2IgPSBbXTtcbiAgICB0aGlzLnZpc2l0KHNvdXJjZSk7XG4gICAgbGV0IHNvdXJjZVRleHQgPSBzb3VyY2Uuc3RhdGVtZW50cy5tYXAoc3RtdCA9PiB7XG4gICAgICBsZXQgc3RyID0gQVNUQnVpbGRlci5idWlsZChzdG10KTtcbiAgICAgIGlmIChpc0NsYXNzKHN0bXQpKSB7XG4gICAgICAgIGxldCBfY2xhc3MgPSA8Q2xhc3NEZWNsYXJhdGlvbj5zdG10O1xuICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMCwgc3RyLmxhc3RJbmRleE9mKFwifVwiKSk7XG4gICAgICAgIGxldCBmaWVsZHMgPSBfY2xhc3MubWVtYmVyc1xuICAgICAgICAgIC5maWx0ZXIoaXNGaWVsZClcbiAgICAgICAgICAubWFwKChmaWVsZDogRmllbGREZWNsYXJhdGlvbikgPT4gZmllbGQpO1xuICAgICAgICBpZiAoZmllbGRzLnNvbWUoZmllbGQgPT4gZmllbGQudHlwZSA9PSBudWxsKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFsbCBGaWVsZHMgbXVzdCBoYXZlIGV4cGxpY3QgdHlwZSBkZWNsYXJhdGlvbi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNsYXNzTmFtZSA9IHRoaXMudHlwZU5hbWUoX2NsYXNzKTtcbiAgICAgICAgc3RyICs9IGBcbiAgZGVjb2RlPFYgPSBVaW50OEFycmF5PihidWY6IFYpOiAke2NsYXNzTmFtZX0ge1xuICAgIGxldCBqc29uOiBKU09OLk9iajtcbiAgICBpZiAoYnVmIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAganNvbiA9IEpTT04ucGFyc2UoYnVmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KGJ1ZiBpbnN0YW5jZW9mIEpTT04uT2JqLCBcImFyZ3VtZW50IG11c3QgYmUgVWludDhBcnJheSBvciBKc29uIE9iamVjdFwiKTtcbiAgICAgIGpzb24gPSA8SlNPTi5PYmo+IGJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZShqc29uKTtcbiAgfVxuXG4gIHN0YXRpYyBkZWNvZGUoYnVmOiBVaW50OEFycmF5KTogJHtjbGFzc05hbWV9IHtcbiAgICByZXR1cm4gZGVjb2RlPCR7Y2xhc3NOYW1lfT4oYnVmKTtcbiAgfVxuXG4gIHByaXZhdGUgX2RlY29kZShvYmo6IEpTT04uT2JqKTogJHtjbGFzc05hbWV9IHtcbiAgICAke2NyZWF0ZURlY29kZVN0YXRlbWVudHMoX2NsYXNzKS5qb2luKFwiXFxuICAgIFwiKX1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIF9lbmNvZGUobmFtZTogc3RyaW5nIHwgbnVsbCA9IFwiXCIsIF9lbmNvZGVyOiBKU09ORW5jb2RlciB8IG51bGwgPSBudWxsKTogSlNPTkVuY29kZXIge1xuICAgIGxldCBlbmNvZGVyID0gKF9lbmNvZGVyID09IG51bGwgPyBuZXcgSlNPTkVuY29kZXIoKSA6IF9lbmNvZGVyKSE7XG4gICAgZW5jb2Rlci5wdXNoT2JqZWN0KG5hbWUpO1xuICAgICR7Y3JlYXRlRW5jb2RlU3RhdGVtZW50cyhfY2xhc3MpLmpvaW4oXCJcXG4gICAgXCIpfVxuICAgIGVuY29kZXIucG9wT2JqZWN0KCk7XG4gICAgcmV0dXJuIGVuY29kZXI7XG4gIH1cbiAgZW5jb2RlKCk6IFVpbnQ4QXJyYXkge1xuICAgIHJldHVybiB0aGlzLl9lbmNvZGUoKS5zZXJpYWxpemUoKTtcbiAgfVxuXG4gIHNlcmlhbGl6ZSgpOiBVaW50OEFycmF5IHtcbiAgICByZXR1cm4gdGhpcy5lbmNvZGUoKTtcbiAgfVxuXG4gIHRvSlNPTigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9lbmNvZGUoKS50b1N0cmluZygpO1xuICB9XG59YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNvdXJjZVRleHQuY29uY2F0KHRoaXMuc2IpLmpvaW4oXCJcXG5cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVjb2RlU3RhdGVtZW50cyhfY2xhc3M6IENsYXNzRGVjbGFyYXRpb24pOiBzdHJpbmdbXSB7XG4gIHJldHVybiBfY2xhc3MubWVtYmVyc1xuICAgIC5maWx0ZXIoaXNGaWVsZClcbiAgICAubWFwKChmaWVsZDogRmllbGREZWNsYXJhdGlvbik6IHN0cmluZyA9PiB7XG4gICAgICBjb25zdCBuYW1lID0gdG9TdHJpbmcoZmllbGQubmFtZSk7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBjcmVhdGVEZWNvZGVTdGF0ZW1lbnQoZmllbGQsIGB0aGlzLiR7bmFtZX0gPSBvYmouaGFzKFwiJHtuYW1lfVwiKSA/IGApICtcbiAgICAgICAgYDogJHtmaWVsZC5pbml0aWFsaXplciAhPSBudWxsID8gQVNUQnVpbGRlci5idWlsZChmaWVsZC5pbml0aWFsaXplcikgOiBgdGhpcy4ke25hbWV9YH07YFxuICAgICAgKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVjb2RlU3RhdGVtZW50KFxuICBmaWVsZDogRmllbGREZWNsYXJhdGlvbiB8IFBhcmFtZXRlck5vZGUsXG4gIHNldHRlclByZWZpeDogc3RyaW5nID0gXCJcIlxuKTogc3RyaW5nIHtcbiAgbGV0IFQgPSB0b1N0cmluZyhmaWVsZC50eXBlISk7XG4gIGxldCBuYW1lID0gdG9TdHJpbmcoZmllbGQubmFtZSk7XG4gIHJldHVybiBgJHtzZXR0ZXJQcmVmaXh9ZGVjb2RlPCR7VH0sIEpTT04uT2JqPihvYmosIFwiJHtuYW1lfVwiKWA7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVuY29kZVN0YXRlbWVudHMoX2NsYXNzOiBDbGFzc0RlY2xhcmF0aW9uKTogc3RyaW5nW10ge1xuICByZXR1cm4gX2NsYXNzLm1lbWJlcnNcbiAgICAuZmlsdGVyKGlzRmllbGQpXG4gICAgLm1hcCgoZmllbGQ6IEZpZWxkRGVjbGFyYXRpb24pOiBzdHJpbmcgPT4ge1xuICAgICAgbGV0IFQgPSB0b1N0cmluZyhmaWVsZC50eXBlISk7XG4gICAgICBsZXQgbmFtZSA9IHRvU3RyaW5nKGZpZWxkLm5hbWUpO1xuICAgICAgcmV0dXJuIGBlbmNvZGU8JHtUfSwgSlNPTkVuY29kZXI+KHRoaXMuJHtuYW1lfSwgXCIke25hbWV9XCIsIGVuY29kZXIpO2A7XG4gICAgfSk7XG59XG4iXX0=